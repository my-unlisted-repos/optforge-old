"""This file is for various python things that require no external libraries."""
import functools
import logging
import operator
import os
import sys
import warnings
from collections.abc import Callable, Iterable, Sequence, MutableMapping
from typing import Any, Optional
import typing


def reduce_dim[T](a: Iterable[Iterable[T]]) -> list[T]: # pylint:disable = E0602
    """ultra fast function that flattens any iterable by one dimension, from there https://stackoverflow.com/a/45323085/15673832"""
    return functools.reduce(operator.iconcat, a, [])

def flatten(iterable: Iterable) -> list:
    if isinstance(iterable, Iterable):
        return [a for i in iterable for a in flatten(i)]
    else:
        return [iterable]

def identity[T](x: T) -> T: return x # pylint:disable = E0602

class Compose:
    """Compose"""
    def __init__(self, *transforms):
        self.transforms = flatten(transforms)

    def __call__(self, x):
        for t in self.transforms:
            x = t(x)
        return x

    def __add__(self, other: "Compose | Callable | Iterable"):
            return Compose(*self.transforms, other)

    def __str__(self):
        return f"Compose({', '.join(str(t) for t in self.transforms)})"

    def __iter__(self):
        return iter(self.transforms)

    def __getitem__(self, i): return self.transforms[i]
    def __setitem__(self, i, v): self.transforms[i] = v
    def __delitem__(self, i): del self.transforms[i]


__valid_fname_chars = frozenset(" -_.,=()")
def to_valid_fname(string:str, fallback = '-', empty_fallback = 'empty', maxlen = 127, valid_chars = __valid_fname_chars) -> str:
    """Makes sure filename doesn't have forbidden characters and isn't empty or too long,
    this does not ensure a valid filename as there are a lot of other rules,
    but does a fine job most of the time.

    Args:
        string (str): _description_
        fallback (str, optional): _description_. Defaults to '-'.
        empty_fallback (str, optional): _description_. Defaults to 'empty'.
        maxlen (int, optional): _description_. Defaults to 127.

    Returns:
        _type_: _description_
    """
    string = ''.join([(c if c in valid_chars or c.isalnum() else fallback) for c in string[:maxlen]])
    if len(string) == 0: return empty_fallback
    return string[:maxlen]

def subclasses_recursive(cls:type | Any) -> set[type]:
    """Recursively get a set of all subclasses of a class (can pass a type or an object of a type)."""
    if not isinstance(cls, type): cls = type(cls)
    return set(cls.__subclasses__()).union(
        [s for c in cls.__subclasses__() for s in subclasses_recursive(c)])

class ShutUp:
    """https://stackoverflow.com/questions/8391411/how-to-block-calls-to-print"""
    def __init__(self, enable=True): self.enable = enable
    def __enter__(self):
        if self.enable:
            logging.captureWarnings(True)
            logging.disable(logging.WARNING)
            warnings.filterwarnings("ignore")
            self._original_stdout = sys.stdout
            sys.stdout = open(os.devnull, 'w') # pylint:disable=W1514

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.enable:
            logging.captureWarnings(False)
            logging.disable(logging.NOTSET)
            sys.stdout.close()
            sys.stdout = self._original_stdout
            warnings.resetwarnings()


def clean_mem():
    """Clean up the traceback information stored in the sys module.

    This function clears the frames from the last traceback and removes the
    last_type, last_value, and last_traceback attributes from the sys module
    if they exist.

    Note:
        This function is based on the implementation by Piotr Czapla.

    Note2:
        The first note was generated by AI but it might still be true.
    """

    # h/t Piotr Czapla
    import gc
    import traceback
    if hasattr(sys, 'last_traceback'):
        traceback.clear_frames(sys.last_traceback)
        delattr(sys, 'last_traceback')
    if hasattr(sys, 'last_type'): delattr(sys, 'last_type')
    if hasattr(sys, 'last_value'): delattr(sys, 'last_value')
    gc.collect()

class bcolors:
    """https://stackoverflow.com/questions/287871/how-do-i-print-colored-text-to-the-terminal"""
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


def str_norm(s:str):
    return ''.join([c.lower() for c in s if c.isalnum()])

_VT = typing.TypeVar("_VT") #  value type

class RelaxedMultikeyDict(MutableMapping[str, _VT]):
    def __init__(self):
        self._prim_to_values: dict[str, Any] = dict()
        """Mapping from primary keys to values"""
        self._relaxed_to_prim: dict[str, str] = dict()
        """Mapping from relaxed keys to primary keys"""
        self._relaxed_to_keys: dict[str, str] = dict()
        """Mapping from relaxed keys to original (non-relaxed) keys"""

    def __getitem__(self, key:str):
        return self._prim_to_values[self._relaxed_to_prim[str_norm(key)]]

    def __contains__(self, keys: str | Sequence[str]) -> bool: # type:ignore
        if isinstance(keys, str): return str_norm(keys) in self._relaxed_to_prim
        return len(set(self._relaxed_to_prim.keys()).intersection([str_norm(i) for i in keys])) > 0

    def __setitem__(self, keys:str | Sequence[str], value):
        if isinstance(keys, str): keys = (keys, )
        relaxed_keys = [str_norm(i) for i in keys]

        if len(set(self._relaxed_to_prim.keys()).intersection(relaxed_keys)) > 0:
            raise ValueError(f'Those keys already exist: {set(self._relaxed_to_prim.keys()).intersection(relaxed_keys)}')

        # 1st key is the primary key
        self._prim_to_values[keys[0]] = value

        for kr, ko in zip(relaxed_keys, keys):
            self._relaxed_to_prim[kr] = keys[0]
            self._relaxed_to_keys[kr] = ko

    def __delitem__(self, key:str) -> None:
        relaxed_key = str_norm(key)
        primary_key = self._relaxed_to_prim[relaxed_key]

        del self._relaxed_to_keys[relaxed_key]
        del self._relaxed_to_prim[relaxed_key]
        del self._prim_to_values[primary_key]

    def __iter__(self):
        return iter(self._prim_to_values)

    def __len__(self):
        return len(self._prim_to_values)

    def keys(self):
        return self._prim_to_values.keys()

    def values(self):
        return self._prim_to_values.values()

    def items(self):
        return self._prim_to_values.items()

    def all_keys(self):
        # returns values which are un-relaxed keys
        return self._relaxed_to_keys.values()

    def all_relaxed_keys(self):
        return self._relaxed_to_keys.keys()

    def relaxed_to_orig(self, key:str):
        return self._relaxed_to_keys[str_norm(key)]

    def update(self, other: "MutableMapping[str | Sequence[str], Any] | RelaxedMultikeyDict") -> None: # type:ignore
        if isinstance(other, RelaxedMultikeyDict):
            self._prim_to_values.update(other._prim_to_values)
            self._relaxed_to_prim.update(other._relaxed_to_prim)
            self._relaxed_to_keys.update(other._relaxed_to_keys)
        else:
            for k, v in other.items():
                self[k] = v


class NicePartial(functools.partial):
    def __repr__(self) -> str:
        if hasattr(self.func, '__name__'): name = self.func.__name__
        else: name = self.func.__class__.__name__
        return f'{name}.partial({", ".join(repr(a) for a in self.args)}, {", ".join(f"{k}={repr(v)}" for k, v in self.keywords.items())})'

def limit_execution_time(sec):
    from concurrent.futures import ThreadPoolExecutor, TimeoutError
    def _time_limiter(func):
        def wrapper_func(*args, **kwargs):
            pool = ThreadPoolExecutor(1)
            future = pool.submit(func, *args, **kwargs)
            try:
                return future.result(sec)
            except TimeoutError:
                print('timeout!')
        return wrapper_func
    return _time_limiter

def limit_execution_time_raise(sec):
    from concurrent.futures import ThreadPoolExecutor
    def _time_limiter(func):
        def wrapper_func(*args, **kwargs):
            pool = ThreadPoolExecutor(1)
            future = pool.submit(func, *args, **kwargs)
            return future.result(sec)
        return wrapper_func
    return _time_limiter

def get__name__(obj:Any) -> str:
    return obj.__name__ if hasattr(obj, '__name__') else obj.__class__.__name__
